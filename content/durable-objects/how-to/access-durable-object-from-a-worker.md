---
title: Access a Durable Object from a Worker
pcx_content_type: concept
weight: 16
---

# Access a Durable Object from a Worker

To access a Durable Object from a Worker, you must first create a Durable Object namespace binding in your Worker. The namespace is, in turn, configured to use a particular class and controls access to instances of that class.

Durable Objects namespace bindings allow you to generate Object IDs and connect to Objects.

If you are using [Wrangler environments](/workers/wrangler/environments/), you must specify any Durable Object namespace bindings you wish to use on a per-environment basis.

## 1. Create Durable Object IDs

An Object ID is a 64-digit hexadecimal number used to identify the Object you are sending the request to. Not all 64-digit hex numbers are valid IDs. The Object ID is tied to a class.

To create a Durable Object ID, you can choose to:

- Generate IDs randomly.
- Derive IDs from names (these names are string data types).
- Parse previously-created IDs from strings.

All three methods will allow you to create Durable Object IDs.  

### Generate IDs randomly

The following code gives you a new Object ID. You can add this code in your `index.js` file.

```js
---
filename: index.js
---
let id = OBJECT_NAMESPACE.newUniqueId();
```

The `newUniqueId()` method on a Durable Object namespace creates a new Object ID randomly. `newUniqueId()` will never return the same ID twice. Thus, it is guaranteed that the Object does not yet exist and has never existed at the time the method returns.

When generating an ID randomly, you need to store the ID somewhere to reach the same Object again in the future. For example, you can store the ID in Workers KV, in an external database, or in a cookie in the user's browser.

Unique IDs are unguessable. You can use unique IDs in URL-based access control.

To store the ID in external storage, use its `toString()` method to convert it into a hexadecimal string, and `OBJECT_NAMESPACE.idFromString()` to convert the string back into an ID later.

{{<Aside type="note" header="Unique IDs perform best">}}

When you construct a new unique ID, the system knows that the same ID will not be generated by another Worker running on the other side of the world at the same time. Therefore, you can instantiate the Object nearby without waiting for any round-the-world synchronization. Whenever you have a convenient place to store the ID, it is recommended to use randomly-generated IDs for best performance.

{{</Aside>}}

### Derive IDs from names

The following code allows you to use a name (which is a `String`) to extract the ID of your Durable Object. 

```js
---
filename: index.js
---
let id = OBJECT_NAMESPACE.idFromName(name);
```

#### Parameters

{{<definitions>}}

- `name` {{<type>}}string{{</type>}}
  - The Object name, an arbitrary string from which the ID is derived.

{{</definitions>}}

This method derives a unique Object ID from the given name string. It will always return the same ID when given the same name as input.

{{<Aside type="note" header="Name-derived IDs require global lookups at creation">}}

The first time you access a Durable Object based on an ID derived from a name, the system does not know anything about the Object. It is possible that a Worker on the opposite side of the world could have coincidentally decided to access the same Object at the same time. To guarantee that only one instance of the Object is created worldwide, the system must check whether the Object has been created anywhere else. Due to the inherent limit of the speed of light, this round-the-world check can take up to a few hundred milliseconds. After this check, the Object will be instantiated near where it was first requested.

After the Object has been accessed the first time, location information will be cached around the world so that subsequent lookups can be faster.

{{</Aside>}}

### Parse previously-created IDs from strings

```js
---
filename: index.js
---
let id = OBJECT_NAMESPACE.idFromString(hexId);
```

#### Parameters

{{<definitions>}}

- `hexId` {{<type>}}string{{</type>}}
  - An ID string constructed by calling the `toString()` method of an existing ID.

{{</definitions>}}

This method parses an ID that was previously stringified. This is useful with IDs created using `newUniqueId()`, as these IDs need to be stored somewhere as a string.

This method will throw an exception if it is passed an ID that was not originally created by `newUniqueId()` or `idFromName()`. It will also throw an exception if the ID was originally created for a different namespace.

## 2. Construct the stub using the ID 

Construct the stub for the Durable Object using the ID. A stub is a client Object used to send messages to the Durable Object.

```js
---
filename: index.js
---
let stub = env.EXAMPLE_CLASS.get(id);
```

## 3. Use `fetch()` handler method

The system calls the `fetch()` method of a Durable Object namespace when an HTTP request is sent to the Object. These requests are not sent from the public Internet, but from other [Workers using a Durable Object namespace binding](/durable-objects/how-to/access-durable-object-from-a-worker/).

The method takes a [`Request`](/workers/runtime-apis/request/) as the parameter and returns a [`Response`](/workers/runtime-apis/response/) (or a `Promise` for a `Response`).

If the method fails with an uncaught exception, the exception will be thrown into the calling Worker that made the `fetch()` request.

```js
---
filename: index.js
---
let response = await stub.fetch(request);
```